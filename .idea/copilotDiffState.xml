<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/studentAnswerTemplate-20251203/Template/Code/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/studentAnswerTemplate-20251203/Template/Code/main.py" />
              <option name="originalContent" value="from PyQt6.QtWidgets import QApplication, QMainWindow, QLabel, QWidget, QPushButton, QVBoxLayout, QHBoxLayout, \&#10;    QSizePolicy&#10;from PyQt6.QtCore import Qt&#10;from PyQt6.QtGui import QPixmap, QFont&#10;import sys&#10;import os&#10;import traceback&#10;# this project should use a modular approach - try to keep UI logic and game logic separate&#10;from game_logic import Game21&#10;&#10;&#10;# get asset paths&#10;def asset_path(*parts):&#10;    return os.path.abspath(os.path.join(os.path.dirname(__file__), '..', *parts))&#10;&#10;&#10;#  create styled QLabel&#10;def make_label(text='', bold=False, color='white'):&#10;    &quot;&quot;&quot;&#10;    Create and return a styled QLabel with simple text color and optional bold font.&#10;&#10;    Parameters:&#10;        text (str): The text to display in the label. Default is an empty string.&#10;        bold (bool): If True, the label text will use a bold weight via stylesheet.&#10;        color (str): CSS color name or hex string for the text color (e.g. 'white' or '#ffffff').&#10;&#10;&#10;    &quot;&quot;&quot;&#10;    # Create the QLabel with the provided text&#10;    lbl = QLabel(text)&#10;&#10;    # Build a small CSS string for styling. Keep it minimal so callers can override&#10;    # or extend styles later if needed (e.g. via `lbl.setStyleSheet(lbl.styleSheet() + '...')`).&#10;    style = f&quot;color: {color};&quot;&#10;&#10;    # Add bold weight if requested. We use CSS here for brevity; QFont is more precise.&#10;    if bold:&#10;        style += &quot; font-weight: bold;&quot;&#10;&#10;    # Apply the stylesheet to the label. This sets only the properties we added above.&#10;    lbl.setStyleSheet(style)&#10;&#10;    # Return the configured label (caller will insert into layouts/parents)&#10;    return lbl&#10;&#10;&#10;class MainWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle('Game of Blackjack 21')  # Set window title&#10;        self.move(200, 200)  # Set initial position&#10;        self.setFixedSize(600, 600)  # Set fixed window size&#10;        self.game = Game21()  # Initialize game logic&#10;        self.stats = {'wins': 0, 'losses': 0, 'pushes': 0}  # Player statistics&#10;        self._font_bold = True  # Font style for labels&#10;        self.initUI()  # Initialize UI&#10;&#10;    def initUI(self):&#10;        central = QWidget()&#10;        self.setCentralWidget(central)&#10;        # BACKGROUND WALLPAPER&#10;        self.wallpaper_path = asset_path('Assets', 'Backgrounds', 'background_1.png')&#10;        self.bg_label = QLabel(central)&#10;        self.bg_label.setScaledContents(True)&#10;        self.bg_label.setGeometry(0, 0, self.width(), self.height())&#10;        self.bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)&#10;        self.bg_label.lower()&#10;        self.wallpaper_pix = None&#10;        if os.path.exists(self.wallpaper_path):&#10;            wp = QPixmap(self.wallpaper_path)&#10;            if not wp.isNull():&#10;                self.wallpaper_pix = wp&#10;                self.bg_label.setPixmap(wp.scaled(self.width(), self.height(), Qt.AspectRatioMode.IgnoreAspectRatio,&#10;                                                  Qt.TransformationMode.SmoothTransformation))&#10;        # MAIN LAYOUT&#10;        self.mainLayout = QVBoxLayout()&#10;        self.mainLayout.setContentsMargins(0, 0, 0, 0)&#10;        central.setLayout(self.mainLayout)&#10;        # DEALER AREA&#10;        self.dealerLabel = make_label('Dealer', bold=self._font_bold)&#10;        self.dealerCardsLayout = QHBoxLayout()&#10;        self.dealerTotalLabel = make_label('Dealer: ?')&#10;        self.mainLayout.addWidget(self.dealerLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        self.mainLayout.addLayout(self.dealerCardsLayout)&#10;        self.mainLayout.addWidget(self.dealerTotalLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        # TABLE AREA&#10;        self.tableContainer = QWidget()&#10;        self.tableContainer.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)&#10;        tableLayout = QVBoxLayout()&#10;        tableLayout.setContentsMargins(0, 0, 0, 0)&#10;        self.tableContainer.setLayout(tableLayout)&#10;        #  FEEDBACK LABEL&#10;        self.feedbackLabel = QLabel('')&#10;        self.feedbackLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        self.feedbackLabel.setStyleSheet('color: white; font-weight: bold; background-color: rgba(0,0,0,0);')&#10;        self.feedbackLabel.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)&#10;        tableLayout.addStretch()&#10;        #  TABLE IMAGE&#10;        table_path = asset_path('Assets', 'Tables', 'table_green.png')&#10;        self.table_pix = None&#10;        self.tableLabel = QLabel()&#10;        self.tableLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        if os.path.exists(table_path):&#10;            pix = QPixmap(table_path)&#10;            if not pix.isNull():&#10;                self.table_pix = pix&#10;                self.update_table_size()&#10;                self.feedbackLabel.setParent(self.tableLabel)&#10;        else:&#10;            self.tableLabel.setText('[Table]')&#10;            self.feedbackLabel.setParent(self.tableContainer)&#10;        tableLayout.addWidget(self.tableLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        tableLayout.addStretch()&#10;        #  STATISTICS WIDGET&#10;        self.statsWidget = QWidget()&#10;        statsLayout = QVBoxLayout()&#10;        statsLayout.setContentsMargins(6, 6, 6, 6)&#10;        self.statsWidget.setLayout(statsLayout)&#10;        statsLayout.addWidget(make_label('Player Statistic:', bold=True))&#10;        self.winLabel = make_label('win : 0')&#10;        self.lossLabel = make_label('loss: 0')&#10;        self.pushLabel = make_label('push: 0')&#10;        statsLayout.addWidget(self.winLabel)&#10;        statsLayout.addWidget(self.lossLabel)&#10;        statsLayout.addWidget(self.pushLabel)&#10;        self.statsWidget.setFixedWidth(140)&#10;        # MID ROW WITH STATS AND TABLE&#10;        midRow = QWidget()&#10;        midLayout = QHBoxLayout()&#10;        midLayout.setContentsMargins(0, 0, 0, 0)&#10;        midRow.setLayout(midLayout)&#10;        midLayout.addWidget(self.statsWidget, alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)&#10;        # center table area&#10;        centerWrapper = QWidget()&#10;        centerLayout = QHBoxLayout()&#10;        centerLayout.setContentsMargins(0, 0, 0, 0)&#10;        centerWrapper.setLayout(centerLayout)&#10;        centerWrapper.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)&#10;        centerLayout.addStretch(1)&#10;        centerLayout.addWidget(self.tableContainer, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        centerLayout.addStretch(1)&#10;        # right spacer to balance stats on left&#10;        self.rightSpacer = QWidget()&#10;        self.rightSpacer.setFixedWidth(self.statsWidget.width())&#10;&#10;        midLayout.addWidget(centerWrapper, stretch=1)&#10;        midLayout.addWidget(self.rightSpacer)&#10;        self.mainLayout.addWidget(midRow)&#10;        # Adjust spacers and background&#10;        self.update_spacers()&#10;        self.update_background()&#10;        self.update_table_size()&#10;        # PLAYER AREA&#10;        self.playerLabel = make_label('Player', bold=self._font_bold)&#10;        self.playerCardsLayout = QHBoxLayout()&#10;        self.playerTotalLabel = make_label('Player: 0')&#10;        self.mainLayout.addWidget(self.playerLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        self.mainLayout.addLayout(self.playerCardsLayout)&#10;        self.mainLayout.addWidget(self.playerTotalLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        # BUTTONS&#10;        self.buttonsLayout = QHBoxLayout()&#10;        self.hitButton = QPushButton('Hit')&#10;        self.standButton = QPushButton('Stand')&#10;        self.newRoundButton = QPushButton('New Round')&#10;        self.hitButton.clicked.connect(self.on_hit)&#10;        self.standButton.clicked.connect(self.on_stand)&#10;        self.newRoundButton.clicked.connect(self.on_new_round)&#10;        self.buttonsLayout.addWidget(self.hitButton)&#10;        self.buttonsLayout.addWidget(self.standButton)&#10;        self.buttonsLayout.addWidget(self.newRoundButton)&#10;        self.mainLayout.addLayout(self.buttonsLayout)&#10;&#10;        self.new_round_setup()&#10;&#10;    def on_hit(self):&#10;        # Player takes a card&#10;        card = self.game.player_hit()&#10;        self.add_card(self.playerCardsLayout, card)&#10;        self.playerTotalLabel.setText(f'Player: {self.game.player_total()}')&#10;        # Check for bust&#10;        if self.game.player_total() &gt; 21:&#10;            self.update_dealer_cards(full=True)&#10;            result = self.game.decide_winner()&#10;            self.update_stats(result)&#10;            self.feedbackLabel.setText(result)&#10;            self.end_round()&#10;&#10;    def on_stand(self):&#10;        self.game.reveal_dealer_card()  # Reveal dealer hidden card&#10;        self.update_dealer_cards(full=True)&#10;        drawn = self.game.play_dealer_turn()&#10;&#10;        for card in drawn:&#10;            self.add_card(self.dealerCardsLayout, card)&#10;        self.dealerTotalLabel.setText(f'Dealer: {self.game.dealer_total()}')&#10;        self.playerTotalLabel.setText(f'Player: {self.game.player_total()}')&#10;        result = self.game.decide_winner()&#10;        self.update_stats(result)&#10;        self.feedbackLabel.setText(result)&#10;        self.end_round()&#10;&#10;    def on_new_round(self):&#10;        # Start a new round&#10;        self.game.new_round()&#10;        self.new_round_setup()&#10;&#10;    # HELPER METHODS&#10;&#10;    def clear_layout(self, layout):&#10;        # Remove all widgets from a layout&#10;        while layout.count():&#10;            item = layout.takeAt(0)&#10;            widget = item.widget()&#10;            if widget:&#10;                widget.deleteLater()&#10;&#10;    # Get the image path for a given card string&#10;    def card_image_path(self, card):&#10;        # Parse rank and suit&#10;        rank = card[:-1]&#10;        suit_symbol = card[-1]&#10;        suit_folder_map = {'♠': 'spade', '♥': 'heart', '♦': 'diamond', '♣': 'club'}&#10;        suit_name_map = {'♠': 'Spades', '♥': 'Hearts', '♦': 'Diamonds', '♣': 'Clubs'}&#10;        # Determine folder and filename&#10;        folder = suit_folder_map.get(suit_symbol, 'spade')&#10;        suitname = suit_name_map.get(suit_symbol, 'Spades')&#10;        filename = f'card{suitname}_{rank}.png'&#10;        path = asset_path('Assets', 'normal_cards', 'individual', folder, filename)&#10;        # Check both possible paths&#10;        if os.path.exists(path):&#10;            return path&#10;        alt_path = asset_path('Assets', 'normal_cards', 'individual', suitname.lower(), filename)&#10;        if os.path.exists(alt_path):&#10;            return alt_path&#10;        return None&#10;&#10;    def add_card(self, layout, card_text, face_down=False):&#10;        # Create a QLabel showing the card value and add it to the chosen layout.&#10;        label = QLabel()&#10;        label.setFixedSize(96, 144)&#10;        label.setScaledContents(True)&#10;        # retrieve card image&#10;        if face_down or card_text == '??':&#10;            back_path = asset_path('Assets', 'normal_cards', 'individual', 'card back', 'cardBackRed.png')&#10;            if os.path.exists(back_path):&#10;                pix = QPixmap(back_path)&#10;                label.setPixmap(pix.scaled(label.width(), label.height(), Qt.AspectRatioMode.KeepAspectRatio,&#10;                                           Qt.TransformationMode.SmoothTransformation))&#10;            else:&#10;                label.setText('XX')&#10;        else:&#10;            # show face-up card&#10;            img_path = self.card_image_path(card_text)&#10;            if img_path and os.path.exists(img_path):&#10;                pix = QPixmap(img_path)&#10;                label.setPixmap(pix.scaled(label.width(), label.height(), Qt.AspectRatioMode.KeepAspectRatio,&#10;                                           Qt.TransformationMode.SmoothTransformation))&#10;            else:&#10;                label.setText(card_text)&#10;        layout.addWidget(label)&#10;        label.setProperty('card', True)&#10;&#10;    def update_dealer_cards(self, full=False):&#10;        # Show dealer cards; hide the first card until revealed&#10;        self.clear_layout(self.dealerCardsLayout)&#10;        for i, card in enumerate(self.game.dealer_hand):&#10;            if i == 0 and not full:&#10;                self.add_card(self.dealerCardsLayout, '??', face_down=True)  # face-down&#10;            else:&#10;                self.add_card(self.dealerCardsLayout, card)&#10;        # TODO: update relevant labels in response to dealer actions. Remove pass when complete&#10;        if full:&#10;            self.dealerTotalLabel.setText(f'Dealer: {self.game.dealer_total()}')&#10;        else:&#10;            self.dealerTotalLabel.setText('Dealer: ?')&#10;&#10;    def new_round_setup(self):&#10;        # Prepare UI for a new round&#10;        self.clear_layout(self.dealerCardsLayout)&#10;        self.clear_layout(self.playerCardsLayout)&#10;        self.feedbackLabel.setText('')&#10;        self.game.deal_initial_cards()&#10;        # Show initial player cards&#10;        for card in self.game.player_hand:&#10;            self.add_card(self.playerCardsLayout, card)&#10;        self.playerTotalLabel.setText(f'Player: {self.game.player_total()}')&#10;        # Show initial dealer cards&#10;        self.update_dealer_cards(full=False)&#10;        self.hitButton.setEnabled(True)&#10;        self.standButton.setEnabled(True)&#10;        self.update_feedback_position()&#10;&#10;    def end_round(self):&#10;        # Disable buttons at round end&#10;        self.hitButton.setEnabled(False)&#10;        self.standButton.setEnabled(False)&#10;&#10;    def update_stats(self, result_text: str):&#10;        # Update win/loss/push statistics based on result text&#10;        if 'Player wins' in result_text or 'Dealer busts' in result_text:&#10;            self.stats['wins'] += 1&#10;        elif 'Dealer wins' in result_text or 'Player busts' in result_text:&#10;            self.stats['losses'] += 1&#10;        elif 'Push' in result_text or 'tie' in result_text:&#10;            self.stats['pushes'] += 1&#10;        self.refresh_stats_label()&#10;&#10;    def refresh_stats_label(self):&#10;        # Update the statistics labels&#10;        self.winLabel.setText(f&quot;win : {self.stats['wins']}&quot;)&#10;        self.lossLabel.setText(f&quot;loss: {self.stats['losses']}&quot;)&#10;        self.pushLabel.setText(f&quot;push: {self.stats['pushes']}&quot;)&#10;&#10;    def update_background(self):&#10;        # Update the background wallpaper to fit the window size&#10;        if os.path.exists(self.wallpaper_path):&#10;            pix = QPixmap(self.wallpaper_path)&#10;            if not pix.isNull():&#10;                scaled = pix.scaled(self.size(), Qt.AspectRatioMode.IgnoreAspectRatio,&#10;                                    Qt.TransformationMode.SmoothTransformation)&#10;                self.bg_label.setPixmap(scaled)&#10;                self.bg_label.setGeometry(0, 0, self.width(), self.height())&#10;        else:&#10;            self.bg_label.clear()&#10;&#10;    def update_spacers(self):&#10;        # Adjust the right spacer width to match stats widget width&#10;        try:&#10;            if hasattr(self, 'rightSpacer') and hasattr(self, 'statsWidget'):&#10;                w = self.statsWidget.width()&#10;                if w &lt;= 0:&#10;                    w = 140&#10;                self.rightSpacer.setFixedWidth(w)&#10;        except Exception:&#10;            pass&#10;&#10;    def update_table_size(self):&#10;        # Resize the table image to fit within the available space&#10;        try:&#10;            # Ensure table_pix is available&#10;            if not hasattr(self, 'table_pix') or self.table_pix is None:&#10;                return&#10;            # Calculate available width&#10;            left_margin = self.statsWidget.width() if hasattr(self, 'statsWidget') else 0&#10;            right_margin = self.rightSpacer.width() if hasattr(self, 'rightSpacer') else left_margin&#10;            available_center_w = max(200, self.width() - left_margin - right_margin - 40)&#10;            default_target_w = max(200, int(self.width() * 0.6))&#10;            target_w = min(default_target_w, available_center_w)&#10;            max_h = max(120, int(self.height() * 0.35))&#10;            if target_w &lt;= 0:&#10;                return&#10;            scaled = self.table_pix.scaled(target_w, max_h, Qt.AspectRatioMode.KeepAspectRatio,&#10;                                           Qt.TransformationMode.SmoothTransformation)&#10;            if not scaled.isNull():&#10;                self.tableLabel.setPixmap(scaled)&#10;                self.tableLabel.setFixedSize(scaled.size())&#10;            self.update_feedback_position()&#10;        except Exception:&#10;            traceback.print_exc()&#10;            return&#10;&#10;    def resizeEvent(self, event):&#10;        # Handle window resize events&#10;        super().resizeEvent(event)&#10;        self.update_spacers()&#10;        self.update_background()&#10;        self.update_table_size()&#10;&#10;    def update_feedback_position(self):&#10;        # Adjust feedback label position and size based on parent widget&#10;        parent_widget = self.feedbackLabel.parentWidget()&#10;        if parent_widget == self.tableLabel:&#10;            tableSize = self.tableLabel.size()&#10;            # Try to fit within 80% width and 40% height of table&#10;            if tableSize.width() &gt; 0:&#10;                allowed_w = int(tableSize.width() * 0.8)&#10;                allowed_h = int(tableSize.height() * 0.4)&#10;                self.feedbackLabel.setWordWrap(True)&#10;                font_size = 12&#10;                min_font = 8&#10;                fitted = False&#10;                while font_size &gt;= min_font:&#10;                    f = QFont()&#10;                    f.setPointSize(font_size)&#10;                    f.setBold(True)&#10;                    self.feedbackLabel.setFont(f)&#10;                    self.feedbackLabel.setFixedWidth(allowed_w)&#10;                    self.feedbackLabel.adjustSize()&#10;                    sh = self.feedbackLabel.sizeHint()&#10;                    # Check if it fits&#10;                    if sh.height() &lt;= allowed_h and sh.width() &lt;= allowed_w:&#10;                        fitted = True&#10;                        self.feedbackLabel.setFixedHeight(sh.height())&#10;                        break&#10;                    font_size -= 1&#10;                    # try smaller font&#10;                if not fitted:&#10;                    self.feedbackLabel.setFixedHeight(allowed_h)&#10;                x = (tableSize.width() - self.feedbackLabel.width()) // 2&#10;                y = (tableSize.height() - self.feedbackLabel.height()) // 2&#10;                self.feedbackLabel.move(x, y)&#10;        else:&#10;            # Center in table container&#10;            geom = (parent_widget.geometry() if parent_widget is not None else self.tableContainer.geometry())&#10;            x = (geom.width() - self.feedbackLabel.width()) // 2&#10;            y = (geom.height() - self.feedbackLabel.height()) // 2&#10;            self.feedbackLabel.move(x, y)&#10;        self.feedbackLabel.raise_()&#10;&#10;&#10;if __name__ == '__main__':&#10;    app = QApplication(sys.argv)&#10;    # macOS only fix for icons appearing&#10;    app.setAttribute(Qt.ApplicationAttribute.AA_DontShowIconsInMenus, False)&#10;&#10;    window = MainWindow()&#10;    window.show()&#10;    sys.exit(app.exec())&#10;" />
              <option name="updatedContent" value="from PyQt6.QtWidgets import QApplication, QMainWindow, QLabel, QWidget, QPushButton, QVBoxLayout, QHBoxLayout, \&#10;    QSizePolicy&#10;from PyQt6.QtCore import Qt&#10;from PyQt6.QtGui import QPixmap, QFont&#10;import sys&#10;import os&#10;import traceback&#10;# this project should use a modular approach - try to keep UI logic and game logic separate&#10;from game_logic import Game21&#10;&#10;&#10;# get asset paths&#10;def asset_path(*parts):&#10;    return os.path.abspath(os.path.join(os.path.dirname(__file__), '..', *parts))&#10;&#10;&#10;#  create styled QLabel&#10;def make_label(text='', bold=False, color='white'):&#10;    &quot;&quot;&quot;&#10;    Create and return a styled QLabel with simple text color and optional bold font.&#10;&#10;    Parameters:&#10;        text (str): The text to display in the label. Default is an empty string.&#10;        bold (bool): If True, the label text will use a bold weight via stylesheet.&#10;        color (str): CSS color name or hex string for the text color (e.g. 'white' or '#ffffff').&#10;&#10;&#10;    &quot;&quot;&quot;&#10;    # Create the QLabel with the provided text&#10;    lbl = QLabel(text)&#10;&#10;    # Build a small CSS string for styling. Keep it minimal so callers can override&#10;    # or extend styles later if needed (e.g. via `lbl.setStyleSheet(lbl.styleSheet() + '...')`).&#10;    style = f&quot;color: {color};&quot;&#10;&#10;    # Add bold weight if requested. We use CSS here for brevity; QFont is more precise.&#10;    if bold:&#10;        style += &quot; font-weight: bold;&quot;&#10;&#10;    # Apply the stylesheet to the label. This sets only the properties we added above.&#10;    lbl.setStyleSheet(style)&#10;&#10;    # Return the configured label (caller will insert into layouts/parents)&#10;    return lbl&#10;&#10;&#10;class MainWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle('Game of Blackjack 21')  # Set window title&#10;        self.move(200, 200)  # Set initial position&#10;        self.setFixedSize(600, 600)  # Set fixed window size&#10;        self.game = Game21()  # Initialize game logic&#10;        self.stats = {'wins': 0, 'losses': 0, 'pushes': 0}  # Player statistics&#10;        self._font_bold = True  # Font style for labels&#10;        self.initUI()  # Initialize UI&#10;&#10;    def initUI(self):&#10;        central = QWidget()&#10;        self.setCentralWidget(central)&#10;        # BACKGROUND WALLPAPER&#10;        self.wallpaper_path = asset_path('Assets', 'Backgrounds', 'background_1.png')&#10;        self.bg_label = QLabel(central)&#10;        self.bg_label.setScaledContents(True)&#10;        self.bg_label.setGeometry(0, 0, self.width(), self.height())&#10;        self.bg_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)&#10;        self.bg_label.lower()&#10;        self.wallpaper_pix = None&#10;        if os.path.exists(self.wallpaper_path):&#10;            wp = QPixmap(self.wallpaper_path)&#10;            if not wp.isNull():&#10;                self.wallpaper_pix = wp&#10;                self.bg_label.setPixmap(wp.scaled(self.width(), self.height(), Qt.AspectRatioMode.IgnoreAspectRatio,&#10;                                                  Qt.TransformationMode.SmoothTransformation))&#10;        # MAIN LAYOUT&#10;        self.mainLayout = QVBoxLayout()&#10;        self.mainLayout.setContentsMargins(0, 0, 0, 0)&#10;        central.setLayout(self.mainLayout)&#10;        # DEALER AREA&#10;        self.dealerLabel = make_label('Dealer', bold=self._font_bold)&#10;        self.dealerCardsLayout = QHBoxLayout()&#10;        self.dealerTotalLabel = make_label('Dealer: ?')&#10;        self.mainLayout.addWidget(self.dealerLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        self.mainLayout.addLayout(self.dealerCardsLayout)&#10;        self.mainLayout.addWidget(self.dealerTotalLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        # TABLE AREA&#10;        self.tableContainer = QWidget()&#10;        self.tableContainer.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)&#10;        tableLayout = QVBoxLayout()&#10;        tableLayout.setContentsMargins(0, 0, 0, 0)&#10;        self.tableContainer.setLayout(tableLayout)&#10;        #  FEEDBACK LABEL&#10;        self.feedbackLabel = QLabel('')&#10;        self.feedbackLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        self.feedbackLabel.setStyleSheet('color: white; font-weight: bold; background-color: rgba(0,0,0,0);')&#10;        self.feedbackLabel.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)&#10;        tableLayout.addStretch()&#10;        #  TABLE IMAGE&#10;        table_path = asset_path('Assets', 'Tables', 'table_green.png')&#10;        self.table_pix = None&#10;        self.tableLabel = QLabel()&#10;        self.tableLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;        if os.path.exists(table_path):&#10;            pix = QPixmap(table_path)&#10;            if not pix.isNull():&#10;                self.table_pix = pix&#10;                self.update_table_size()&#10;                self.feedbackLabel.setParent(self.tableLabel)&#10;        else:&#10;            self.tableLabel.setText('[Table]')&#10;            self.feedbackLabel.setParent(self.tableContainer)&#10;        tableLayout.addWidget(self.tableLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        tableLayout.addStretch()&#10;        #  STATISTICS WIDGET&#10;        self.statsWidget = QWidget()&#10;        statsLayout = QVBoxLayout()&#10;        statsLayout.setContentsMargins(6, 6, 6, 6)&#10;        self.statsWidget.setLayout(statsLayout)&#10;        statsLayout.addWidget(make_label('Player Statistic:', bold=True))&#10;        self.winLabel = make_label('win : 0')&#10;        self.lossLabel = make_label('loss: 0')&#10;        self.pushLabel = make_label('push: 0')&#10;        statsLayout.addWidget(self.winLabel)&#10;        statsLayout.addWidget(self.lossLabel)&#10;        statsLayout.addWidget(self.pushLabel)&#10;        self.statsWidget.setFixedWidth(140)&#10;        # MID ROW WITH STATS AND TABLE&#10;        midRow = QWidget()&#10;        midLayout = QHBoxLayout()&#10;        midLayout.setContentsMargins(0, 0, 0, 0)&#10;        midRow.setLayout(midLayout)&#10;        midLayout.addWidget(self.statsWidget, alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)&#10;        # center table area&#10;        centerWrapper = QWidget()&#10;        centerLayout = QHBoxLayout()&#10;        centerLayout.setContentsMargins(0, 0, 0, 0)&#10;        centerWrapper.setLayout(centerLayout)&#10;        centerWrapper.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)&#10;        centerLayout.addStretch(1)&#10;        centerLayout.addWidget(self.tableContainer, alignment=Qt.AlignmentFlag.AlignCenter)&#10;        centerLayout.addStretch(1)&#10;        # right spacer to balance stats on left&#10;        self.rightSpacer = QWidget()&#10;        self.rightSpacer.setFixedWidth(self.statsWidget.width())&#10;&#10;        midLayout.addWidget(centerWrapper, stretch=1)&#10;        midLayout.addWidget(self.rightSpacer)&#10;        self.mainLayout.addWidget(midRow)&#10;        # Adjust spacers and background&#10;        self.update_spacers()&#10;        self.update_background()&#10;        self.update_table_size()&#10;        # PLAYER AREA&#10;        self.playerLabel = make_label('Player', bold=self._font_bold)&#10;        self.playerCardsLayout = QHBoxLayout()&#10;        self.playerTotalLabel = make_label('Player: 0')&#10;        self.mainLayout.addWidget(self.playerLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        self.mainLayout.addLayout(self.playerCardsLayout)&#10;        self.mainLayout.addWidget(self.playerTotalLabel, alignment=Qt.AlignmentFlag.AlignHCenter)&#10;        # BUTTONS&#10;        self.buttonsLayout = QHBoxLayout()&#10;        self.hitButton = QPushButton('Hit')&#10;        self.standButton = QPushButton('Stand')&#10;        self.newRoundButton = QPushButton('New Round')&#10;        self.hitButton.clicked.connect(self.on_hit)&#10;        self.standButton.clicked.connect(self.on_stand)&#10;        self.newRoundButton.clicked.connect(self.on_new_round)&#10;        self.buttonsLayout.addWidget(self.hitButton)&#10;        self.buttonsLayout.addWidget(self.standButton)&#10;        self.buttonsLayout.addWidget(self.newRoundButton)&#10;        self.mainLayout.addLayout(self.buttonsLayout)&#10;&#10;        self.new_round_setup()&#10;&#10;    def on_hit(self):&#10;        # Player takes a card&#10;        card = self.game.player_hit()&#10;        self.add_card(self.playerCardsLayout, card)&#10;        self.playerTotalLabel.setText(f'Player: {self.game.player_total()}')&#10;        # Check for bust&#10;        if self.game.player_total() &gt; 21:&#10;            self.update_dealer_cards(full=True)&#10;            result = self.game.decide_winner()&#10;            self.update_stats(result)&#10;            self.feedbackLabel.setText(result)&#10;            self.end_round()&#10;&#10;    def on_stand(self):&#10;        self.game.reveal_dealer_card()  # Reveal dealer hidden card&#10;        self.update_dealer_cards(full=True)&#10;        drawn = self.game.play_dealer_turn()&#10;&#10;        for card in drawn:&#10;            self.add_card(self.dealerCardsLayout, card)&#10;        self.dealerTotalLabel.setText(f'Dealer: {self.game.dealer_total()}')&#10;        self.playerTotalLabel.setText(f'Player: {self.game.player_total()}')&#10;        result = self.game.decide_winner()&#10;        self.update_stats(result)&#10;        self.feedbackLabel.setText(result)&#10;        self.end_round()&#10;&#10;    def on_new_round(self):&#10;        # Start a new round&#10;        self.game.new_round()&#10;        self.new_round_setup()&#10;&#10;    # HELPER METHODS&#10;&#10;    def clear_layout(self, layout):&#10;        # Remove all widgets from a layout&#10;        while layout.count():&#10;            item = layout.takeAt(0)&#10;            widget = item.widget()&#10;            if widget:&#10;                widget.deleteLater()&#10;&#10;    # Get the image path for a given card string&#10;    def card_image_path(self, card):&#10;        # Parse rank and suit&#10;        rank = card[:-1]&#10;        suit_symbol = card[-1]&#10;        suit_folder_map = {'♠': 'spade', '♥': 'heart', '♦': 'diamond', '♣': 'club'}&#10;        suit_name_map = {'♠': 'Spades', '♥': 'Hearts', '♦': 'Diamonds', '♣': 'Clubs'}&#10;        # Determine folder and filename&#10;        folder = suit_folder_map.get(suit_symbol, 'spade')&#10;        suitname = suit_name_map.get(suit_symbol, 'Spades')&#10;        filename = f'card{suitname}_{rank}.png'&#10;        path = asset_path('Assets', 'normal_cards', 'individual', folder, filename)&#10;        # Check both possible paths&#10;        if os.path.exists(path):&#10;            return path&#10;        alt_path = asset_path('Assets', 'normal_cards', 'individual', suitname.lower(), filename)&#10;        if os.path.exists(alt_path):&#10;            return alt_path&#10;        return None&#10;&#10;    def add_card(self, layout, card_text, face_down=False):&#10;        # Create a QLabel showing the card value and add it to the chosen layout.&#10;        label = QLabel()&#10;        label.setFixedSize(96, 144)&#10;        label.setScaledContents(True)&#10;        # retrieve card image&#10;        if face_down or card_text == '??':&#10;            back_path = asset_path('Assets', 'normal_cards', 'individual', 'card back', 'cardBackRed.png')&#10;            if os.path.exists(back_path):&#10;                pix = QPixmap(back_path)&#10;                label.setPixmap(pix.scaled(label.width(), label.height(), Qt.AspectRatioMode.KeepAspectRatio,&#10;                                           Qt.TransformationMode.SmoothTransformation))&#10;            else:&#10;                label.setText('XX')&#10;        else:&#10;            # show face-up card&#10;            img_path = self.card_image_path(card_text)&#10;            if img_path and os.path.exists(img_path):&#10;                pix = QPixmap(img_path)&#10;                label.setPixmap(pix.scaled(label.width(), label.height(), Qt.AspectRatioMode.KeepAspectRatio,&#10;                                           Qt.TransformationMode.SmoothTransformation))&#10;            else:&#10;                label.setText(card_text)&#10;        layout.addWidget(label)&#10;        label.setProperty('card', True)&#10;&#10;    def update_dealer_cards(self, full=False):&#10;        # Show dealer cards; hide the first card until revealed&#10;        self.clear_layout(self.dealerCardsLayout)&#10;        for i, card in enumerate(self.game.dealer_hand):&#10;            if i == 0 and not full:&#10;                self.add_card(self.dealerCardsLayout, '??', face_down=True)  # face-down&#10;            else:&#10;                self.add_card(self.dealerCardsLayout, card)&#10;        # TODO: update relevant labels in response to dealer actions. Remove pass when complete&#10;        if full:&#10;            self.dealerTotalLabel.setText(f'Dealer: {self.game.dealer_total()}')&#10;        else:&#10;            self.dealerTotalLabel.setText('Dealer: ?')&#10;&#10;    def new_round_setup(self):&#10;        # Prepare UI for a new round&#10;        self.clear_layout(self.dealerCardsLayout)&#10;        self.clear_layout(self.playerCardsLayout)&#10;        self.feedbackLabel.setText('')&#10;        self.game.deal_initial_cards()&#10;        # Show initial player cards&#10;        for card in self.game.player_hand:&#10;            self.add_card(self.playerCardsLayout, card)&#10;        self.playerTotalLabel.setText(f'Player: {self.game.player_total()}')&#10;        # Show initial dealer cards&#10;        self.update_dealer_cards(full=False)&#10;        self.hitButton.setEnabled(True)&#10;        self.standButton.setEnabled(True)&#10;        self.update_feedback_position()&#10;&#10;    def end_round(self):&#10;        # Disable buttons at round end&#10;        self.hitButton.setEnabled(False)&#10;        self.standButton.setEnabled(False)&#10;&#10;    def update_stats(self, result_text: str):&#10;        # Update win/loss/push statistics based on result text&#10;        if 'Player wins' in result_text or 'Dealer busts' in result_text:&#10;            self.stats['wins'] += 1&#10;        elif 'Dealer wins' in result_text or 'Player busts' in result_text:&#10;            self.stats['losses'] += 1&#10;        elif 'Push' in result_text or 'tie' in result_text:&#10;            self.stats['pushes'] += 1&#10;        self.refresh_stats_label()&#10;&#10;    def refresh_stats_label(self):&#10;        # Update the statistics labels&#10;        self.winLabel.setText(f&quot;win : {self.stats['wins']}&quot;)&#10;        self.lossLabel.setText(f&quot;loss: {self.stats['losses']}&quot;)&#10;        self.pushLabel.setText(f&quot;push: {self.stats['pushes']}&quot;)&#10;&#10;    def update_background(self):&#10;        # Update the background wallpaper to fit the window size&#10;        if os.path.exists(self.wallpaper_path):&#10;            pix = QPixmap(self.wallpaper_path)&#10;            if not pix.isNull():&#10;                scaled = pix.scaled(self.size(), Qt.AspectRatioMode.IgnoreAspectRatio,&#10;                                    Qt.TransformationMode.SmoothTransformation)&#10;                self.bg_label.setPixmap(scaled)&#10;                self.bg_label.setGeometry(0, 0, self.width(), self.height())&#10;        else:&#10;            self.bg_label.clear()&#10;&#10;    def update_spacers(self):&#10;        # Adjust the right spacer width to match stats widget width&#10;        try:&#10;            if hasattr(self, 'rightSpacer') and hasattr(self, 'statsWidget'):&#10;                w = self.statsWidget.width()&#10;                if w &lt;= 0:&#10;                    w = 140&#10;                self.rightSpacer.setFixedWidth(w)&#10;        except Exception:&#10;            pass&#10;&#10;    def update_table_size(self):&#10;        # Resize the table image to fit within the available space&#10;        try:&#10;            # Ensure table_pix is available&#10;            if not hasattr(self, 'table_pix') or self.table_pix is None:&#10;                return&#10;            # Calculate available width&#10;            left_margin = self.statsWidget.width() if hasattr(self, 'statsWidget') else 0&#10;            right_margin = self.rightSpacer.width() if hasattr(self, 'rightSpacer') else left_margin&#10;            available_center_w = max(200, self.width() - left_margin - right_margin - 40)&#10;            default_target_w = max(200, int(self.width() * 0.6))&#10;            target_w = min(default_target_w, available_center_w)&#10;            max_h = max(120, int(self.height() * 0.35))&#10;            if target_w &lt;= 0:&#10;                return&#10;            scaled = self.table_pix.scaled(target_w, max_h, Qt.AspectRatioMode.KeepAspectRatio,&#10;                                           Qt.TransformationMode.SmoothTransformation)&#10;            if not scaled.isNull():&#10;                self.tableLabel.setPixmap(scaled)&#10;                self.tableLabel.setFixedSize(scaled.size())&#10;            self.update_feedback_position()&#10;        except Exception:&#10;            traceback.print_exc()&#10;            return&#10;&#10;    def resizeEvent(self, event):&#10;        # Handle window resize events&#10;        super().resizeEvent(event)&#10;        self.update_spacers()&#10;        self.update_background()&#10;        self.update_table_size()&#10;&#10;    def update_feedback_position(self):&#10;        # Adjust feedback label position and size based on parent widget&#10;        parent_widget = self.feedbackLabel.parentWidget()&#10;        if parent_widget == self.tableLabel:&#10;            tableSize = self.tableLabel.size()&#10;            # Try to fit within 80% width and 40% height of table&#10;            if tableSize.width() &gt; 0:&#10;                allowed_w = int(tableSize.width() * 0.8)&#10;                allowed_h = int(tableSize.height() * 0.4)&#10;                self.feedbackLabel.setWordWrap(True)&#10;                font_size = 12&#10;                min_font = 8&#10;                fitted = False&#10;                while font_size &gt;= min_font:&#10;                    f = QFont()&#10;                    f.setPointSize(font_size)&#10;                    f.setBold(True)&#10;                    self.feedbackLabel.setFont(f)&#10;                    self.feedbackLabel.setFixedWidth(allowed_w)&#10;                    self.feedbackLabel.adjustSize()&#10;                    sh = self.feedbackLabel.sizeHint()&#10;                    # Check if it fits&#10;                    if sh.height() &lt;= allowed_h and sh.width() &lt;= allowed_w:&#10;                        fitted = True&#10;                        self.feedbackLabel.setFixedHeight(sh.height())&#10;                        break&#10;                    font_size -= 1&#10;                    # try smaller font&#10;                if not fitted:&#10;                    self.feedbackLabel.setFixedHeight(allowed_h)&#10;                x = (tableSize.width() - self.feedbackLabel.width()) // 2&#10;                y = (tableSize.height() - self.feedbackLabel.height()) // 2&#10;                self.feedbackLabel.move(x, y)&#10;        else:&#10;            # Center in table container&#10;            geom = (parent_widget.geometry() if parent_widget is not None else self.tableContainer.geometry())&#10;            x = (geom.width() - self.feedbackLabel.width()) // 2&#10;            y = (geom.height() - self.feedbackLabel.height()) // 2&#10;            self.feedbackLabel.move(x, y)&#10;        self.feedbackLabel.raise_()&#10;&#10;&#10;if __name__ == '__main__':&#10;    app = QApplication(sys.argv)&#10;    # macOS only fix for icons appearing&#10;    app.setAttribute(Qt.ApplicationAttribute.AA_DontShowIconsInMenus, False)&#10;&#10;    window = MainWindow()&#10;    window.show()&#10;    sys.exit(app.exec())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>